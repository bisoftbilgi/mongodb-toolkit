input {
  file {
    path => ["${MONGO_LOG_PATH}"]
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_mongo"
    codec => "json"
  }
}

filter {
  # -----------------------------
  # Path normalize (ECS on/off)
  # -----------------------------
  if ![path] and [log][file][path] {
    mutate { replace => { "path" => "%{[log][file][path]}" } }
  }

  # /logs/mongo-01/mongod.log -> server_id=mongo-01
  dissect { mapping => { "path" => "/logs/%{server_id}/%{filename}" } }

  translate {
    field           => "server_id"
    destination     => "server_meta_json"
    dictionary_path => "/usr/share/logstash/extra/servers.yml"
    fallback        => "{\"cluster_name\":\"unknown\",\"server_name\":\"unknown\",\"server_ip\":\"0.0.0.0\"}"
  }

  json { source => "server_meta_json" target => "server_meta" }

  mutate {
    replace => {
      "cluster_name" => "%{[server_meta][cluster_name]}"
      "server_name"  => "%{[server_meta][server_name]}"
      "server_ip"    => "%{[server_meta][server_ip]}"
    }
    remove_field => ["server_meta_json","server_meta"]
  }

  mutate {
    rename => {
      "msg" => "message"
      "ctx" => "context"
      "c"   => "component"
    }
  }

  # -----------------------------
  # Defaults for stable schema
  # -----------------------------
  mutate {
    add_field => {
      "event_type"        => "other"
      "username"          => "unknown"
      "db_name"           => "unknown"
      "client_ip"         => "unknown"
      "application_name"  => "unknown"

      # Audit defaults
      "session_id"        => "unknown"
      "audit_type"        => "OTHER"
      "statement_text"    => ""
      "command"           => "unknown"
      "object_type"       => "unknown"
      "object_name"       => "unknown"
      "duration_ms"       => 0
    }
  }

  # -----------------------------
  # Connection events (4 types)
  # -----------------------------
  if [component] == "ACCESS" and [message] == "Successfully authenticated" {
    mutate { replace => { "event_type" => "auth_success" } }
  } else if [component] == "ACCESS" and [message] == "Connection not authenticating" {
    mutate { replace => { "event_type" => "auth_failed" } }
  } else if [component] == "NETWORK" and [message] == "Connection ended" {
    mutate { replace => { "event_type" => "connection_ended" } }
  } else if [message] == "Interrupted operation as its client disconnected" {
    mutate { replace => { "event_type" => "client_disconnected" } }
  }

  # Connection: client ip parsing
  if [event_type] in ["auth_success","auth_failed","connection_ended","client_disconnected"] {
    if [attr][client] {
      grok { match => { "[attr][client]" => "%{IP:client_ip}" } overwrite => ["client_ip"] }
    } else if [attr][remote] {
      grok { match => { "[attr][remote]" => "%{IP:client_ip}" } overwrite => ["client_ip"] }
    }

    if [event_type] in ["auth_success","auth_failed"] and [attr][user] {
      mutate { replace => { "username" => "%{[attr][user]}" } }
    }

    if [event_type] in ["auth_success","auth_failed"] and [attr][db] {
      mutate { replace => { "db_name" => "%{[attr][db]}" } }
    }

    if [attr][doc][application][name] {
      mutate { replace => { "application_name" => "%{[attr][doc][application][name]}" } }
    }

    mutate { add_field => { "action" => "%{event_type}" "log_time" => "%{@timestamp}" } }
    mutate { add_tag => ["mongo_connection_log"] }
  }

  # -----------------------------
  # Audit events (Slow query)
  # -----------------------------
  if [component] == "COMMAND" and [message] == "Slow query" {

    # --- NOISE FILTERING START ---
    if [attr][command][hello] or [attr][command][ismaster] or [attr][command][isMaster] { drop { } }
    if [attr][command][topologyVersion] { drop { } }
    if [attr][command][maxAwaitTimeMS] { drop { } }
    if [attr][command][helloOk] { drop { } }
    if [attr][command][replSetHeartbeat] { drop { } }
    if [attr][command][buildInfo] or [attr][command][getLog] { drop { } }
    if [attr][command][serverStatus] or [attr][command][ping] { drop { } }
    if [attr][command][listIndexes] or [attr][command][listCollections] { drop { } }
    if [attr][ns] =~ /^config\.(system\.sessions|transactions)/ { drop { } }
    if [attr][command][$db] == "config" and [attr][ns] =~ /config\.\$cmd/ { drop { } }
    if [attr][ns] =~ /system\.sessions/ { drop { } }
    if [attr][command][endSessions] { drop { } }
    if [attr][command][saslStart] or [attr][command][saslContinue] { drop { } }
    if [attr][command][getParameter] or [attr][command][setParameter] { drop { } }
    if [attr][command][featureCompatibilityVersion] { drop { } }
    # --- NOISE FILTERING END ---
    
    # Parse core audit fields
    if [attr][appName] {
      mutate { replace => { "application_name" => "%{[attr][appName]}" } }
    }

    if [attr][remote] {
      grok { match => { "[attr][remote]" => "%{IP:client_ip}" } overwrite => ["client_ip"] }
    }

    if [attr][durationMillis] {
      mutate { replace => { "duration_ms" => "%{[attr][durationMillis]}" } }
    }

    # db_name parsing
    if [attr][command][$db] {
      mutate { replace => { "db_name" => "%{[attr][command][$db]}" } }
    } else if [attr][ns] {
      ruby {
        code => "
          ns = event.get('[attr][ns]')
          if ns && ns.include?('.')
            event.set('db_name', ns.split('.',2)[0])
          end
        "
      }
    }

    # object_type + object_name
    if [attr][collectionType] and [attr][collectionType] != "normal" {
      mutate { replace => { "object_type" => "%{[attr][collectionType]}" } }
    } else {
      mutate { replace => { "object_type" => "collection" } }
    }

    # Object Name Extraction Ruby Logic
    ruby {
      code => "
        ns = event.get('[attr][ns]')
        if ns && ns.include?('.')
          parts = ns.split('.', 2)
          collection = parts[1]
          if collection == '$cmd'
            cmd = event.get('[attr][command]')
            if cmd.is_a?(Hash)
              ['insert', 'update', 'delete', 'find', 'create', 'drop', 
               'dropIndexes', 'createIndexes', 'aggregate', 'count', 'distinct',
               'findAndModify', 'renameCollection'].each do |op|
                if cmd[op] && cmd[op] != 1 && cmd[op] != true
                  collection = cmd[op].to_s
                  break
                end
              end
            end
          end
          event.set('object_name', collection)
        elsif ns
          event.set('object_name', ns)
        end
      "
    }

    # statement_text as JSON string
    ruby {
      code => "
        cmd = event.get('[attr][command]')
        if cmd
          begin
            event.set('statement_text', cmd.to_json)
          rescue
          end
        end
      "
    }

    # Command name extraction
    ruby {
      code => "
        cmd = event.get('[attr][command]')
        if cmd.is_a?(Hash)
          operations = [
            'findAndModify', 'find', 'insert', 'update', 'delete', 'aggregate', 'count', 'distinct',
            'create', 'drop', 'createIndexes', 'dropIndexes',
            'createUser', 'updateUser', 'dropUser', 'createRole', 'dropRole',
            'grantRolesToUser', 'revokeRolesFromUser', 'grantRolesToRole', 'revokeRolesFromRole',
            'renameCollection', 'collMod'
          ]
          command_name = nil
          operations.each do |op|
            if cmd.key?(op)
              command_name = op
              break
            end
          end
          if command_name.nil?
            ignore = ['$db','lsid','$readPreference','$clusterTime','$configTime',
                      '$topologyTime','writeConcern','readConcern','ordered','cursor',
                      'sort','projection','filter','limit','skip','batchSize','remove',
                      'upsert','query','new','bypassDocumentValidation','updates','deletes']
            command_name = cmd.keys.find { |x| !ignore.include?(x.to_s) }
          end
          event.set('command', command_name.to_s) if command_name
        end
      "
    }

    # session_id extraction
    if [attr][command][lsid][id][$uuid] {
      mutate { replace => { "session_id" => "%{[attr][command][lsid][id][$uuid]}" } }
    }

    # audit_type mapping
    if [command] in ["find","aggregate","count","distinct"] {
      mutate { replace => { "audit_type" => "DQL" } }
    } else if [command] in ["insert","update","delete","findAndModify"] {
      mutate { replace => { "audit_type" => "DML" } }
    } else if [command] in ["create","drop","createIndexes","dropIndexes","collMod","renameCollection"] {
      mutate { replace => { "audit_type" => "DDL" } }
    } else if [command] in ["createUser","updateUser","dropUser","grantRolesToUser","revokeRolesFromUser","createRole","dropRole","grantRolesToRole","revokeRolesFromRole"] {
      mutate { replace => { "audit_type" => "DCL" } }
    } else {
      mutate { replace => { "audit_type" => "OTHER" } }
    }

    mutate { add_field => { "log_time" => "%{@timestamp}" } }
    mutate { add_tag => ["mongo_audit_log"] }
  }

  # Keep only connection/audit events
  if "mongo_connection_log" not in [tags] and "mongo_audit_log" not in [tags] {
    drop { }
  }

  # Cleanup
  mutate {
    remove_field => ["event", "log", "component", "context", "attr", "id", "s", "@version", "host"]
  }
}

output {
  stdout { codec => rubydebug }

  # Connection table
  if "mongo_connection_log" in [tags] {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB_NAME}"
      driver_class      => "org.postgresql.Driver"
      driver_jar_path   => "/usr/share/logstash/logstash-core/lib/jars/postgresql-42.7.8.jar"
      username          => "${PG_USER}"
      password          => "${PG_PASSWORD}"
      statement => [
        "INSERT INTO mongo_connection_logs (log_time, username, database_name, client_ip, action, cluster_name, server_name, server_ip, application_name)
         VALUES (?::timestamptz, ?, ?, ?, ?, ?, ?, ?, ?)",
        "log_time","username","db_name","client_ip","action","cluster_name","server_name","server_ip","application_name"
      ]
      flush_size => 1
      max_pool_size => 5
    }
  }

  # Audit table
  if "mongo_audit_log" in [tags] {
    jdbc {
      connection_string => "jdbc:postgresql://${PG_HOST}:${PG_PORT}/${PG_DB_NAME}"
      driver_class      => "org.postgresql.Driver"
      driver_jar_path   => "/usr/share/logstash/logstash-core/lib/jars/postgresql-42.7.8.jar"
      username          => "${PG_USER}"
      password          => "${PG_PASSWORD}"
      statement => [
        "INSERT INTO mongo_audit_logs
         (log_time, username, database_name, session_id, audit_type, statement_text, command, object_type, object_name, duration_ms,
          cluster_name, server_name, server_ip, client_ip, application_name)
         VALUES (?::timestamptz, ?, ?, ?, ?, ?, ?, ?, ?, ?::int, ?, ?, ?, ?, ?)",
        "log_time","username","db_name","session_id","audit_type","statement_text","command","object_type","object_name","duration_ms",
        "cluster_name","server_name","server_ip","client_ip","application_name"
      ]
      flush_size => 1
      max_pool_size => 5
    }
  }
}
